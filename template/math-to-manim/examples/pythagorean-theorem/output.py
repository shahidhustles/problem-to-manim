"""
Pythagorean Theorem Animation
Generated by Math-To-Manim Pipeline

Run with: manim -pql output.py PythagoreanTheorem
"""

from manim import *
import numpy as np


class PythagoreanTheorem(Scene):
    """
    Complete animation of the Pythagorean theorem,
    building from foundational concepts to the visual proof.
    """

    # Color palette for consistency
    PRIMARY = BLUE
    SECONDARY = GREEN
    HIGHLIGHT = GOLD
    ACCENT = YELLOW
    LEG_A_COLOR = RED
    LEG_B_COLOR = GREEN
    HYPOTENUSE_COLOR = BLUE

    def construct(self):
        # Scene progression
        self.scene_angles()
        self.scene_triangle_sides()
        self.scene_right_triangle()
        self.scene_multiplication()
        self.scene_squares_on_sides()
        self.scene_equality()
        self.scene_visual_proof()

    def scene_angles(self):
        """Scene 1: Foundation - Angles"""
        # Create angle visualization
        line1 = Line(ORIGIN, 2*RIGHT, color=WHITE)
        line2 = Line(ORIGIN, 2*UP + RIGHT, color=WHITE)

        angle_arc = Arc(
            radius=0.5,
            start_angle=0,
            angle=np.arctan2(2, 1),
            color=self.ACCENT
        )

        theta = MathTex(r"\theta", color=self.ACCENT)
        theta.next_to(angle_arc, RIGHT, buff=0.2)

        explanation = Text("Angles measure rotation", font_size=28)
        explanation.to_edge(DOWN)

        # Animations
        self.play(Create(line1), Create(line2))
        self.play(Create(angle_arc))
        self.play(Write(theta))
        self.play(FadeIn(explanation))
        self.wait(2)

        # Cleanup
        self.play(
            FadeOut(line1), FadeOut(line2),
            FadeOut(angle_arc), FadeOut(theta),
            FadeOut(explanation)
        )

    def scene_triangle_sides(self):
        """Scene 2: Sides of a Triangle"""
        # Create a general triangle
        triangle = Polygon(
            [-2, -1, 0], [2, -1, 0], [0, 1.5, 0],
            color=self.PRIMARY
        )

        # Labels
        label_a = Text("a", font_size=32, color=self.SECONDARY)
        label_b = Text("b", font_size=32, color=self.SECONDARY)
        label_c = Text("c", font_size=32, color=self.SECONDARY)

        label_a.next_to(triangle, LEFT)
        label_b.next_to(triangle, RIGHT)
        label_c.next_to(triangle, DOWN)

        explanation = Text("Every triangle has three sides", font_size=28)
        explanation.to_edge(DOWN)

        # Animations
        self.play(Create(triangle), run_time=2)
        self.play(
            Write(label_a),
            Write(label_b),
            Write(label_c),
            lag_ratio=0.3
        )
        self.play(FadeIn(explanation))
        self.wait(1)

        # Store for next scene and shift
        self.triangle_group = VGroup(triangle, label_a, label_b, label_c)
        self.play(
            FadeOut(explanation),
            self.triangle_group.animate.shift(2*LEFT)
        )

    def scene_right_triangle(self):
        """Scene 3: Right Triangle"""
        # Create right triangle
        right_triangle = Polygon(
            [-1, -1, 0], [2, -1, 0], [-1, 1.5, 0],
            color=self.PRIMARY
        )

        # Right angle marker
        right_angle = Square(side_length=0.3, color=self.ACCENT)
        right_angle.move_to([-1 + 0.15, -1 + 0.15, 0])

        # Equation
        angle_eq = MathTex(r"\angle C = 90°", color=self.ACCENT)
        angle_eq.to_edge(UP)

        # Labels
        hyp_label = Text("hypotenuse (c)", font_size=24, color=self.HYPOTENUSE_COLOR)
        leg_label = Text("legs (a, b)", font_size=24, color=self.SECONDARY)

        hyp_label.next_to(right_triangle, UR, buff=0.5)
        leg_label.next_to(right_triangle, DL, buff=0.5)

        # Transform from previous triangle
        self.play(
            ReplacementTransform(self.triangle_group, right_triangle)
        )
        self.play(FadeIn(right_angle))
        self.play(Write(angle_eq))
        self.play(
            FadeIn(hyp_label),
            FadeIn(leg_label)
        )
        self.play(
            Indicate(right_angle),
            Indicate(angle_eq)
        )
        self.wait(1)

        # Store and cleanup
        self.right_triangle = right_triangle
        self.play(
            FadeOut(angle_eq),
            FadeOut(hyp_label),
            FadeOut(leg_label),
            FadeOut(right_angle)
        )

    def scene_multiplication(self):
        """Scene 4: Multiplication and Area"""
        # Shift triangle to side
        self.play(self.right_triangle.animate.scale(0.5).to_edge(LEFT))

        # Create demonstration square
        square = Square(side_length=2, color=self.SECONDARY)
        square.set_fill(self.SECONDARY, opacity=0.5)
        square.move_to(ORIGIN)

        # Area equation
        area_eq = MathTex(r"A = s \times s = s^2", color=WHITE)
        area_eq.to_edge(UP)

        # Animations
        self.play(Create(square))
        self.play(Write(area_eq))
        self.play(Indicate(area_eq[0][7:9]))  # Highlight s²
        self.wait(1)

        # Cleanup
        self.play(
            FadeOut(square),
            FadeOut(area_eq),
            self.right_triangle.animate.scale(2).move_to(ORIGIN)
        )

    def scene_squares_on_sides(self):
        """Scene 5: Squares on Triangle Sides"""
        # Create the right triangle with precise vertices
        A = np.array([-1, -1, 0])  # Right angle vertex
        B = np.array([2, -1, 0])   # End of side a
        C = np.array([-1, 1.5, 0]) # End of side b

        # Recreate triangle
        triangle = Polygon(A, B, C, color=self.PRIMARY)
        self.play(ReplacementTransform(self.right_triangle, triangle))

        # Calculate side lengths
        a = np.linalg.norm(B - A)  # Bottom side
        b = np.linalg.norm(C - A)  # Left side
        c = np.linalg.norm(C - B)  # Hypotenuse

        # Square on side a (bottom)
        square_a = Square(side_length=a, color=self.LEG_A_COLOR)
        square_a.set_fill(self.LEG_A_COLOR, opacity=0.5)
        square_a.move_to([(A[0] + B[0])/2, A[1] - a/2, 0])

        # Square on side b (left)
        square_b = Square(side_length=b, color=self.LEG_B_COLOR)
        square_b.set_fill(self.LEG_B_COLOR, opacity=0.5)
        square_b.move_to([A[0] - b/2, (A[1] + C[1])/2, 0])

        # Square on hypotenuse (simplified positioning)
        square_c = Square(side_length=c, color=self.HYPOTENUSE_COLOR)
        square_c.set_fill(self.HYPOTENUSE_COLOR, opacity=0.5)
        # Rotate and position along hypotenuse
        hyp_angle = np.arctan2(C[1] - B[1], C[0] - B[0])
        square_c.rotate(hyp_angle)
        hyp_midpoint = (B + C) / 2
        offset = np.array([np.sin(hyp_angle), -np.cos(hyp_angle), 0]) * c/2
        square_c.move_to(hyp_midpoint + offset)

        # Area equations
        eq_a = MathTex(r"A_a = a^2", color=self.LEG_A_COLOR)
        eq_b = MathTex(r"A_b = b^2", color=self.LEG_B_COLOR)
        eq_c = MathTex(r"A_c = c^2", color=self.HYPOTENUSE_COLOR)

        equations = VGroup(eq_a, eq_b, eq_c)
        equations.arrange(DOWN, buff=0.3)
        equations.to_edge(RIGHT)

        # Animations - grow squares from edges
        self.play(GrowFromEdge(square_a, UP))
        self.play(Write(eq_a))
        self.play(GrowFromEdge(square_b, RIGHT))
        self.play(Write(eq_b))
        self.play(GrowFromEdge(square_c, LEFT))
        self.play(Write(eq_c))

        self.wait(2)

        # Store for next scene
        self.squares_group = VGroup(triangle, square_a, square_b, square_c)
        self.equations_group = equations

    def scene_equality(self):
        """Scene 6: The Key Equality"""
        # Shift diagram to left
        self.play(
            self.squares_group.animate.scale(0.6).to_edge(LEFT),
            FadeOut(self.equations_group)
        )

        # Main theorem equation
        theorem = MathTex(r"a^2 + b^2 = c^2", color=self.HIGHLIGHT)
        theorem.scale(1.5)
        theorem.move_to(2*RIGHT)

        explanation = Text(
            "Sum of squares on legs = square on hypotenuse",
            font_size=24
        )
        explanation.next_to(theorem, DOWN, buff=0.5)

        # Animations
        self.play(Write(theorem), run_time=2)
        self.play(Circumscribe(theorem, color=self.HIGHLIGHT))
        self.play(FadeIn(explanation))
        self.wait(2)

        # Store theorem
        self.theorem = theorem
        self.explanation = explanation

    def scene_visual_proof(self):
        """Scene 7: Visual Proof and Conclusion"""
        # Highlight the squares on legs
        self.play(
            Indicate(self.squares_group[1]),  # square_a
            Indicate(self.squares_group[2]),  # square_b
            color=self.ACCENT
        )

        # Show combined area equals hypotenuse square
        self.play(
            Indicate(self.squares_group[3]),  # square_c
            color=self.ACCENT
        )

        # Final presentation
        self.play(
            FadeOut(self.squares_group),
            FadeOut(self.explanation)
        )

        # Center the main equation
        self.play(self.theorem.animate.move_to(ORIGIN).scale(1.2))

        # Add the alternative form
        alt_form = MathTex(r"c = \sqrt{a^2 + b^2}", color=self.HIGHLIGHT)
        alt_form.scale(1.2)
        alt_form.next_to(self.theorem, DOWN, buff=0.5)

        self.play(Write(alt_form))

        # Title
        title = Text("The Pythagorean Theorem", font_size=48, color=WHITE)
        title.to_edge(UP)

        self.play(Write(title))

        # Final highlight
        final_group = VGroup(self.theorem, alt_form)
        self.play(Circumscribe(final_group, color=self.HIGHLIGHT))

        self.wait(3)

        # Fade out
        self.play(
            FadeOut(title),
            FadeOut(self.theorem),
            FadeOut(alt_form)
        )


if __name__ == "__main__":
    # For testing: render at preview quality
    # manim -pql output.py PythagoreanTheorem
    pass
